Index: codex-rs/arg0/src/lib.rs
--- codex-rs/arg0/src/lib.rs.orig	Thu Nov 13 11:59:48 2025
+++ codex-rs/arg0/src/lib.rs	Thu Nov 13 14:31:52 2025
@@ -76,10 +76,13 @@
     // before creating any threads/the Tokio runtime.
     load_dotenv();
 
+    // Resolve the executable path from argv0
+    let self_exe = resolve_self_exe(&argv0)?;
+
     // Retain the TempDir so it exists for the lifetime of the invocation of
     // this executable. Admittedly, we could invoke `keep()` on it, but it
     // would be nice to avoid leaving temporary directories behind, if possible.
-    let _path_entry = match prepend_path_entry_for_apply_patch() {
+    let _path_entry = match prepend_path_entry_for_apply_patch(&self_exe) {
         Ok(path_entry) => Some(path_entry),
         Err(err) => {
             // It is possible that Codex will proceed successfully even if
@@ -93,11 +96,7 @@
     // async entry-point.
     let runtime = tokio::runtime::Runtime::new()?;
     runtime.block_on(async move {
-        let codex_linux_sandbox_exe: Option<PathBuf> = if cfg!(target_os = "linux") {
-            std::env::current_exe().ok()
-        } else {
-            None
-        };
+        let codex_linux_sandbox_exe = Some(self_exe.clone());
 
         main_fn(codex_linux_sandbox_exe).await
     })
@@ -144,17 +143,15 @@
 ///
 /// IMPORTANT: This function modifies the PATH environment variable, so it MUST
 /// be called before multiple threads are spawned.
-fn prepend_path_entry_for_apply_patch() -> std::io::Result<TempDir> {
+fn prepend_path_entry_for_apply_patch(exe: &Path) -> std::io::Result<TempDir> {
     let temp_dir = TempDir::new()?;
     let path = temp_dir.path();
 
     for filename in &[APPLY_PATCH_ARG0, MISSPELLED_APPLY_PATCH_ARG0] {
-        let exe = std::env::current_exe()?;
-
         #[cfg(unix)]
         {
             let link = path.join(filename);
-            symlink(&exe, &link)?;
+            symlink(exe, &link)?;
         }
 
         #[cfg(windows)]
@@ -193,4 +190,73 @@
     }
 
     Ok(temp_dir)
+}
+
+
+fn resolve_self_exe(argv0: &std::ffi::OsStr) -> std::io::Result<PathBuf> {
+    #[cfg(unix)]
+    {
+        resolve_self_exe_unix(argv0)
+    }
+    #[cfg(not(unix))]
+    {
+        let _ = argv0;
+        std::env::current_exe()
+    }
+}
+
+#[cfg(unix)]
+fn resolve_self_exe_unix(argv0: &std::ffi::OsStr) -> std::io::Result<PathBuf> {
+    use std::io::{Error, ErrorKind};
+    use std::os::unix::ffi::OsStrExt;
+
+    if argv0.is_empty() {
+        return Err(Error::new(
+            ErrorKind::NotFound,
+            "argv[0] is empty; cannot resolve executable path",
+        ));
+    }
+
+    let candidate = PathBuf::from(argv0);
+    if candidate.is_absolute() {
+        return Ok(candidate);
+    }
+
+    if argv0.as_bytes().contains(&b'/') {
+        return Ok(std::env::current_dir()?.join(candidate));
+    }
+
+    if let Some(paths) = std::env::var_os("PATH") {
+        for dir in std::env::split_paths(&paths) {
+            let dir = if dir.as_os_str().is_empty() {
+                std::env::current_dir()?
+            } else {
+                dir
+            };
+            let resolved = dir.join(&candidate);
+            if is_executable_file(&resolved) {
+                return Ok(resolved);
+            }
+        }
+    } else {
+        let resolved = std::env::current_dir()?.join(&candidate);
+        if is_executable_file(&resolved) {
+            return Ok(resolved);
+        }
+    }
+
+    Err(Error::new(
+        ErrorKind::NotFound,
+        format!("failed to locate '{}' on PATH; cannot determine executable path", candidate.display()),
+    ))
+}
+
+#[cfg(unix)]
+fn is_executable_file(path: &Path) -> bool {
+    use std::os::unix::fs::PermissionsExt;
+
+    match std::fs::metadata(path) {
+        Ok(metadata) => metadata.is_file() && metadata.permissions().mode() & 0o111 != 0,
+        Err(_) => false,
+    }
 }
