Index: codex-rs/arg0/src/lib.rs
--- codex-rs/arg0/src/lib.rs.orig
+++ codex-rs/arg0/src/lib.rs
@@ -1,6 +1,7 @@
 use std::future::Future;
 use std::path::Path;
 use std::path::PathBuf;
+use std::sync::OnceLock;
 
 use codex_core::CODEX_APPLY_PATCH_ARG1;
 #[cfg(unix)]
@@ -10,7 +11,10 @@
 const LINUX_SANDBOX_ARG0: &str = "codex-linux-sandbox";
 const APPLY_PATCH_ARG0: &str = "apply_patch";
 const MISSPELLED_APPLY_PATCH_ARG0: &str = "applypatch";
+const CODEX_SELF_EXE_ENV_VAR: &str = "CODEX_SELF_EXE";
 
+static SELF_EXE: OnceLock<PathBuf> = OnceLock::new();
+
 pub fn arg0_dispatch() -> Option<TempDir> {
     // Determine if we were invoked via the special alias.
     let mut args = std::env::args_os();
@@ -51,7 +55,23 @@
     // before creating any threads/the Tokio runtime.
     load_dotenv();
 
-    match prepend_path_entry_for_codex_aliases() {
+    let self_exe = match resolve_self_exe(&argv0) {
+        Ok(path) => {
+            let _ = SELF_EXE.set(path.clone());
+            unsafe {
+                std::env::set_var(CODEX_SELF_EXE_ENV_VAR, &path);
+            }
+            path
+        }
+        Err(err) => {
+            eprintln!(
+                "WARNING: proceeding, even though we could not determine executable path: {err}"
+            );
+            return None;
+        }
+    };
+
+    match prepend_path_entry_for_codex_aliases(&self_exe) {
         Ok(path_entry) => Some(path_entry),
         Err(err) => {
             // It is possible that Codex will proceed successfully even if
@@ -92,16 +112,20 @@
     // this executable. Admittedly, we could invoke `keep()` on it, but it
     // would be nice to avoid leaving temporary directories behind, if possible.
     let _path_entry = arg0_dispatch();
+    let cached_self_exe = SELF_EXE.get().cloned();
 
     // Regular invocation â€“ create a Tokio runtime and execute the provided
     // async entry-point.
     let runtime = tokio::runtime::Runtime::new()?;
     runtime.block_on(async move {
-        let codex_linux_sandbox_exe: Option<PathBuf> = if cfg!(target_os = "linux") {
-            std::env::current_exe().ok()
-        } else {
-            None
-        };
+        let codex_linux_sandbox_exe: Option<PathBuf> =
+            if cfg!(target_os = "linux") {
+                cached_self_exe
+                    .clone()
+                    .or_else(|| std::env::current_exe().ok())
+            } else {
+                None
+            };
 
         main_fn(codex_linux_sandbox_exe).await
     })
@@ -148,7 +172,7 @@
 ///
 /// IMPORTANT: This function modifies the PATH environment variable, so it MUST
 /// be called before multiple threads are spawned.
-pub fn prepend_path_entry_for_codex_aliases() -> std::io::Result<TempDir> {
+pub fn prepend_path_entry_for_codex_aliases(exe: &Path) -> std::io::Result<TempDir> {
     let temp_dir = TempDir::new()?;
     let path = temp_dir.path();
 
@@ -158,12 +182,10 @@
         #[cfg(target_os = "linux")]
         LINUX_SANDBOX_ARG0,
     ] {
-        let exe = std::env::current_exe()?;
-
         #[cfg(unix)]
         {
             let link = path.join(filename);
-            symlink(&exe, &link)?;
+            symlink(exe, &link)?;
         }
 
         #[cfg(windows)]
@@ -203,3 +225,75 @@
 
     Ok(temp_dir)
 }
+
+fn resolve_self_exe(argv0: &std::ffi::OsStr) -> std::io::Result<PathBuf> {
+    #[cfg(unix)]
+    {
+        resolve_self_exe_unix(argv0)
+    }
+    #[cfg(not(unix))]
+    {
+        let _ = argv0;
+        std::env::current_exe()
+    }
+}
+
+#[cfg(unix)]
+fn resolve_self_exe_unix(argv0: &std::ffi::OsStr) -> std::io::Result<PathBuf> {
+    use std::io::{Error, ErrorKind};
+    use std::os::unix::ffi::OsStrExt;
+
+    if argv0.is_empty() {
+        return Err(Error::new(
+            ErrorKind::NotFound,
+            "argv[0] is empty; cannot resolve executable path",
+        ));
+    }
+
+    let candidate = PathBuf::from(argv0);
+    if candidate.is_absolute() {
+        return Ok(candidate);
+    }
+
+    if argv0.as_bytes().contains(&b'/') {
+        return Ok(std::env::current_dir()?.join(candidate));
+    }
+
+    if let Some(paths) = std::env::var_os("PATH") {
+        for dir in std::env::split_paths(&paths) {
+            let dir = if dir.as_os_str().is_empty() {
+                std::env::current_dir()?
+            } else {
+                dir
+            };
+            let resolved = dir.join(&candidate);
+            if is_executable_file(&resolved) {
+                return Ok(resolved);
+            }
+        }
+    } else {
+        let resolved = std::env::current_dir()?.join(&candidate);
+        if is_executable_file(&resolved) {
+            return Ok(resolved);
+        }
+    }
+
+    Err(Error::new(
+        ErrorKind::NotFound,
+        format!(
+            "failed to locate '{}' on PATH; cannot determine executable path",
+            candidate.display()
+        ),
+    ))
+}
+
+#[cfg(unix)]
+fn is_executable_file(path: &Path) -> bool {
+    use std::os::unix::fs::PermissionsExt;
+
+    match std::fs::metadata(path) {
+        Ok(metadata) => metadata.is_file() && metadata.permissions().mode() & 0o111 != 0,
+        Err(_) => false,
+    }
+}
+
